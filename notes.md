# Конспект по введению в контроль версий 

## Лекция 1

#### Для чего нужен контроль версий?

* Возможность хранить различные версии проекта
* Возможность возвращаться к различным версиям проекта

**Git** - это программа, которая берет на себя вопросы контроля версий над проектом (*не единственная система*).

**Git** - сохраняет только разницу между старым принципом и дополнением, а когда мы захотим воспользоваться файлом **Git** сам "соберет" его (*тем самым экономит память*).

**Для работы потребуется**

* Установить на ПК Git
 
 https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-Git 

* Настроить его

#### Что нужно

* Сохранять разные версии
* Перемещаться между ними 

После установки необходимо «представиться» системе контроля версий. Это нужно сделать всего один раз, и **git** запомнит вас. Для этого нужно ввести в терминале 2 команды:
- **git config --global user.name** «Ваше имя англ буквами»
- **git config --global user.email** ваша_почта@example.com

#### Комманды для работы с Git

- **git --version** - узнать версию **git**.
- **git init** - инициализация **git** (*git будет отслеживать все изменения в данной папке*).
- **git status** - показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе.
- **git add <file_name>** -добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита.
- **git commit -m "Комментарий"** - берёт все данные, добавленные в индекс с помощью _git add_, и сохраняет их слепок во внутренней базе данных.
- **git log** - отображает коммиты.
- **git diff** - используется для вычисления разницы между любыми двумя Git деревьями.
- **git checkout** - копирует файлы со сцены в рабочую директорию.
- **git checkout master** - вернуться в самое актуальное состояние. 

#### Руководство по синтаксису Markdown

- Добавление заголовка - (# ) перед словом
- Добавление заголовка второго уровня - (## ) перед словом.
- Выделение _курсивом_ - обрамляем слово с обоих сторон (*) или (_).
- Выделение **полужирным** - обрамляем слово с обоих сторон (**).
- Ненумерованный список - (* ) или (- ) перед элементом списка, например:
    - Элемент 1
    - Элемент 2
- Нумерованный список - (1.) перед элементом, например:
    1. Элемент 1
    2. Элемент 2
- Вложенные списки - выполняем отступы.
- ~~Зачеркивание~~ - (~~) - до и после текста.

## Лекция 2

#### Работа с черновиками

##### git branch

Если у нас несколько версий черновика, мы можем вывести на экран ветку, где находимся, командой **git branch**.

Создать ветку можно коьандой **git branch**. Делать это надо в папке с репозиторием:
**git branch <название новой ветки>**

![](/img/command_branch.PNG)

Для чистовика используем ветку **master** и для чистовика создадим новую ветку.

![](/img/command_branch1.PNG) 

Коммандой **git checkout <имя ветки>** перключаемся с одной ветки на другую.

![](/img/command_checkout.PNG)  

Команда **git log** покажет состояние более новых
версий проекта. Но если вызвать эту команду из
самой «свежей» ветки, мы не увидим исходного
файла.

Когда мы правим текст/код в текущей ветке,
автоматического слияния не происходит: можно
создавать один документ в разных версиях 
в разных ветках.

Допустим, черновики нас полностью устраивают и нам нужно внести изменения, чтобы
информация появилась в чистовике. Для этого есть команда **git merge**.

#### Совмещение двух вариантов текста

##### git merge

Чтобы слить любую ветку с текущей, вызываем
**git merge <имя ветки для слияния с текущей>**

![](/img/command_marge.PNG)

![](/img/command_merge1.PNG)

После всех изменений дерево версий принимает следующий вид:

![](/img/change_tree.PNG)

#### Удоление веток

Если ветка больше не нужна, ее можно удалить командой: **git branch -d <имя ветки>**.

![](/img/branch_delete.PNG)

#### Добавление изображения

В **Git** не принято добавлять файлы
изображений, их хранят на сторонних
носителях. Чтобы исключить ненужные файлы
из загрузки, есть команда **git ignore**.

#### Конфликт изменений

При работе в двух ветках одновременно может
возникнуть ситуация, когда в одной и другой
ветке мы по-разному изменили блок текста.
Если затем мы попробуем слить эти ветки, Git
сообщит о конфликте и предложит выбрать,
какие же изменения записать.

![](/img/conflict.PNG)

Поэтому у проекта в репозитории должен быть один
ответственный пользователь, наделённый правом проводить слияния и разрешать конфликты.

#### Визуализация всех веток

##### git log --graph

Ключ -graf в связке с командой log позволяет отобразить коммиты в виде дерева.

![](/img/command_log_graph.PNG)

## Лекция 3

